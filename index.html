<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>자바 정리!</title>
<style>
@font-face {
    font-family: 'D2Coding';
    src: url('https://cdn.jsdelivr.net/gh/projectnoonnu/noonfonts_three@1.0/D2Coding.woff') format('woff');
    font-weight: normal;
    font-style: normal;
}

body { background-color: black; font-size: 15px; }
details {background-color:black;}
 summary {position: relative; left: 6px;
 border: 1px solid white;
  padding-left: 5px; font-size: 40px
  ;
 font-family: D2Coding; color: white;}
.second { padding-left: 3em;}
#con {font-size: 30px; color: white;
position: relative; left: 6px;
padding: 0px; margin:0px; 
border: 1px solid white;}
.third { padding-left: 3em;}
#con {font-size: 30px; color: white;
position: relative; left: 12px;
padding: 0px; margin:0px; 
border: 1px solid white;}
#con2 {font-size: 30px; color: white;
position: relative; left: 52px;
padding: 13px; margin: 0px; 
border: 1px solid white;}
#space { padding-left:20px;}
p {margin-top: 0px; padding-top: 0px;
margin-bottom: 0px; padding-bottom: 0px; }
#ver {color:grey;}
</style>
</head>
<body >
<div id="ver">Collection Iterator 설명, interface, class, exception, stream, network</div>
<details>
   <summary>Var&Type</summary>
	   <details class="second">
	   <summary>Variable</summary>
	   <div id="con"> <div id="space">
	   	변수 선언<br>
	   	변수 초기화<br>
	   	scope {}<br>
	   	변수 사용 범위확인 (static 과 non-static 구분)
	   </div> </div>
	</details>
	<details class="second">
	   <summary>Type</summary>
	   <div id="con"> <div id="space">
	   	byte, short, int, long,  char<br>
	   	float, double<br>
	   	boolean
	   </div> </div>
	</details>
</details>
<details>
   <summary>Operator</summary>
	   <div id="con">	   <div id="space">
		대입: =, +=, -=, *=, /=. %=, &=. ^=, |=, <<=, >>=, >>>= <br>
		산술: +, -, *, % <br>
		증감: ++, -- <br>
		비교: ==, !=, >, >=, <, <= <br>
		논리: &&, ||, !, &, |<br>
		비트: &, !, ~, ^, <<, >>, >>><br>
		3항: (조건식) ? (true) : (flase)<br>
		문자열: +
	   </div>	   </div>
	</details>
</details>
<details>
   <summary>Control</summary>
	   <details class="second">
	   <summary>Conditional</summary>
			<details class="third">
	   		<summary>if</summary>
			   <div id="con"> <div id="space">
			   	if (boolean) {<br>
			   	} else if (boolean) {<br>
			   	} else <br>
			   	}
			   </div> </div>
	   	</details>
	   		<details class="third">
	   		<summary>switch</summary>
			   <div id="con"> <div id="space">
			   	switch (var){<br>
			   	case (값):<br>
			   	case (값):<br>
			   	default : <br>
			   	}
			   </div> </div>
	   	</details>
	</details>
<details class="second">
	   <summary>Repeat</summary>
			<details class="third">
	   		<summary>for</summary>
			   <div id="con"> <div id="space">
			   	for ( (초기화) ; (boolean) ; (증감식) ) {<br>
			   	}<br>
			   </div></div>
	   	</details>
	   		<details class="third">
	   		<summary>while</summary>
			   <div id="con"> <div id="space">
			   	while (boolean) {<br>
			   	}<br>
			   </div> </div>
	</details>
	</details>
		   <div id="con2">
			   	break;<br>
			   	continue;<br>
			   </div>
</details>
<details>
   <summary>Array</summary>
	   <div id="con"><div id="space">
		   <table>
		   <tr>
		   <td>* 1. 배열변수 선언	</td>
		   <td>int[] score;</td>
		   </tr>
		   <tr>
		   <td>* 2. 배열 메모리 할당	</td>
		   <td>score = new int[5];</td>
		   </tr>
		   <tr>
		   <td>* 3.  배열 원소 초기화	</td>
		   <td>score[0]=3; score[1]=4;</td>
		   </tr>
		   <tr>
		   <td>* 4. 사용	</td>
		   <td>score[0]*2;</td>
		   </tr>
		   <tr>
		   <td id="space"> 배열 초기화를 간단하게 하는 다른 방법</td>
		   <td> </td>
		   </tr>
		   <tr>
		   <td id=space>int[] num = new int[] {1,2,3};</td>
		   <td> </td>
		   </tr>
	   </table>
	   </div></div>
	</details>
</details>
<details>
   <summary>Extends</summary>
   	   <details class="second">
	   <summary>Extends</summary>
	   <div id="con">
	   <div id="space">
	   public class Motorcycle extends Vehicle {<br>
	   기본생성자 public Motorcycle() { super() <br>}<br>
	   생성자 오버로드 public Motorcycle( type var, type var, type var...) {<br>
	   this.var = var ...  <br> }<br>
	   	@Override <br>
	   	type method() {<br>}<br>
	   </div></div>
	   	</details>
	   		<details class="third">
	   		<summary>Access</summary>
			   <div id="con"> <div id="space">
			   	public<br>
			   	protected<br>
			   	(default)<br>
			   	private
			   </div> </div>
	   	</details>
	   	<details class="third">
	   		<summary>Abstract</summary>
			   <div id="con"> <div id="space">
			Access abstract class name {<br>
			 type var; <br>
			 } <br>
			구현부는 없고 선언부만 존재 (method 가 있으면 안됨! new 사용x 부모로만 사용) <br><br>
			
			abstract type method(); <br>
			추상 메소드 (반드시 구현해야함(Override)) <br>
			   </div> </div>
	   	</details>
	   	<details class="third">
	   		<summary>final</summary>
			   <div id="con"> <div id="space">
			Access final class name { }<br>
			 상속 불가 <br>
			Access final method() <br>
			오버라이드 불가 <br>
			   </div> </div>
	   	</details>
	</details>

<details>
   <summary>Collection</summary>
   <details class="second">
	   <summary>List</summary>
			<details class="third">
		   		<summary>ArrayList</summary>
				   <div id="con"> <div id="space">
				순서가 정해지고 중복이 허옹되는 List
				<br>검색 유리 추가/삭제 불리
				<br>선언
				<br>List name = new ArrayList();
				<br>ArrayList name = new ArrayList();
				<br>ArrayList&lt;Wrapper&gt; <!--<>--> 
				name = new ArrayList&lt;&gt;();
				<br>* value 저장
				<br><p>name.add()
				<br>name.set(index, Object)</p>
				* List size
				<br><p>name.size()</p>
				* value 의 유/무
				<br><p>boolean bName = name.contains(value);<p>
				* all value -> String
				<p>name.toString</p>
				* value -> array[]
				<p>type[] arrayName = new type[name.size()];
				<br>type[] arrayName = (type)name.toArray(arrayName);</p>
				* value 사용
				<br><p>name.get(#) (wrapper -> cast)<p>
				* Object/Index 삭제	 
				<br><p>name.remove(객체/인덱스)<p>
							* delete all value
				<p>name.clear</p>
				   </div> </div>
	   		</details>
	   		<details class="third">
		   		<summary>LinkedList</summary>
				   <div id="con"> <div id="space">
				순서가 정해지고 중복이 허옹되는 List
				<br>검색 불리 추가/삭제 유리
				<br>선언
				<br>List name = new LinkedList();
				<br>LinkedList name = new LinkedList();
				<br>LinkedList&lt;wrapper&gt; <!--<>--> 
				name = new LinkedList&lt;&gt;();
				<br>* value 저장
				<br><p>name.add()
				<br>name.set(index, Object)</p>
				* List size
				<br><p>name.size()</p>
				* all value -> String
				<p>name.toString</p>
				* value -> array[]
				<p>type[] arrayName = new type[name.size()];
				<br>type[] arrayName = (type)name.toArray(arrayName)</p>
				* value 사용
				<br><p>name.get(#) (wrapper->cast)<p>
							* delete all value
				<p>name.clear</p>
				   </div> </div>
	   		</details>
	</details>
	
	<details class="second">
	   <summary>Set</summary>
			<details class="third">
		   		<summary>HashSet</summary>
				   <div id="con"> <div id="space">
					순서가 정해지지 않고 중복이 불허되는 Set
				<br>선언
				<br>Set name = new HashSet();
				<br>HashSet name = new HashSet();
				<br>HashSet&lt;Wrapper&gt; <!--<>--> 
				name = new HashSet&lt;&gt;();
				<br>
				* value 저장
				<br><p>name.add()</p>
				* Set size
				<br><p>name.size()</p>
				* all value -> String
				<p>name.toString</p>
				* value -> array[]
				<p>type[] arrayName = new type[name.size()];
				<br>type[] arrayName = (type)name.toArray(arrayName)</p>
				* get 사용불가능 (순서가 없으므로)
				<p> Iterator로 연결 </p>
				* delete all value
				<p>name.clear</p>
		
				   </div> </div>
	   		</details>
	</details>
	
	   <details class="second">
	   <summary>Map</summary>
			<details class="third">
		   		<summary>HashMap</summary>
				   <div id="con"> <div id="space">
		키(key)와 값(value)을 묶어 하나의 데이터로 저장한다
				<br>동기화x return Fail-Fast Iterator
				<br>선언
				<br>HashMap&lt;wrapper, wrapper&gt; <!--<>--> 
				name = new HashMap&lt;&gt;();
				<br>
				* Map이 비어있는지? 참/거짓	 (boolean)
				<br><p>name.put(key,value)</p>
				<br>
				* value 저장
				<br><p>name.put(key,value)</p>
				<br>
				* value 교체
				<br><p>name.replace(key,value)</p>
				* value 복제
				<br><p>name.clone()</p>
				* List size
				<br><p>name.size()</p>
				* Set keySet()	HashMap에 저장된 모든 키가 저장된 Set을 반환
				<p>Set keySet()</p>
				* value 사용
				<br><p>name.get(key)<p>
				* value delete
				<p>name.remove(value)</p>
				* delete all value
				<p>name.clear</p>
				   </div> </div>
	   		</details>
	   		<details class="third">
		   		<summary>HashTable</summary>
				   <div id="con"> <div id="space">
			키(key)와 값(value)을 묶어 하나의 데이터로 저장한다
				<br>동기화o return Enumeration
				<br>선언
				<br>HashMap&lt;wrapper, wrapper&gt; <!--<>--> 
				name = new HashMap&lt;&gt;();
				<br>
				<br>HashTable&lt;wrapper, wrapper&gt; <!--<>--> 
				name = new HashTable&lt;&gt;();
				<br>
				* Map/Table이 비어있는지? 참/거짓	 (boolean)
				<br><p>name.put(key,value)</p>
				<br>
				* value 저장
				<br><p>name.put(key,value)</p>
				* value 교체
				<br><p>name.replace(key,value)</p>
				* value 복제
				<br><p>name.clone()</p>
				* List size
				<br><p>name.size()</p>
				* Set keySet()	HashMap에 저장된 모든 키가 저장된 Set을 반환
				<p>Set keySet()</p>
				* value 사용
				<br><p>name.get(key)<p>
				* value delete
				<p>name.remove(value)</p>
				* delete all value
				<p>name.clear</p>
				   </div> </div>
	   		</details>
	</details>
	
	   <details class="second">
	   <summary>Iterator</summary>
				   <div id="con"> <div id="space">
				컬렉션에 저장되어 있는 요소들을 읽어오는 방법의 인터페이스
				<br>검색 불리 추가/삭제 유리
				<br>선언
				<br>Iterator name = null; Iterator은 final
				<br>LinkedList name = new LinkedList();
				<br>Iterator&lt;Wrppere&gt; <!--<>--> name = 
				name.iterator();
				<br>
				* 읽어올 다음 요소가 있는지?
				<br><p>boolean bName = name.hasnext();</p>
				* 다음 요소 읽어옴
				<br><p>type tName = name.next();
				<br><p>Object oName = name.next();</p>
						* 읽어온 요소 삭제
				<br><p>name.remove();</p>

				   </div> </div>
	   		</details>
	</details>
		

</details>

<details>
   <summary>Interface</summary>
	   <details class="second">
	   <summary>	Click Me! 2</summary>
	   <p>details, summary 같이 적용</p>
	</details>
</details>

<details>
   <summary>Class</summary>
	   <details class="second">
	   <summary>	Click Me! 2</summary>
	   <p>details, summary 같이 적용</p>
	</details>
</details>

<details>
   <summary>Exception</summary>
	   <details class="second">
	   <summary>	Click Me! 2</summary>
	   <p>details, summary 같이 적용</p>
	</details>
</details>

<details>
   <summary>Stream</summary>
	<details class="second">
	   <summary>Node Stream</summary>
			<details class="third">
	   		<summary>FileReader</summary>
			   <div id="con"> <div id="space">
			   	데이터 소스는 파일이며 텍스트를 입력하는 스트림<br>
			   </div> </div>
	   	</details>
	   		<details class="third">
	   		<summary>FileWriter</summary>
			   <div id="con"> <div id="space">
				파일에 문자를 출력하는 스트림<br>
			   </div> </div>
	   	</details>
	   		   		<details class="third">
	   		<summary>FileInputStream</summary>
			   <div id="con"> <div id="space">
파일에서 바이트 데이터를 입력하는 스트림<br>
			   </div> </div>
	   	</details>
	   		   		<details class="third">
	   		<summary>FileOutputStream</summary>
			   <div id="con"> <div id="space">
파일에서 바이트 데이를 출력하는 스트림<br>
			   </div> </div>
	   	</details>
	   	
	   	
	   	

	</details>
<details class="second">
	   <summary>Filter Stream</summary>
			<details class="third">
	   		<summary>BufferedReader</summary>
			   <div id="con"> <div id="space">
버퍼를 사용하여 성능 향상, 한행 단위로 읽어올 수 있다.<br>
			   </div> </div>
	   	</details>
	   		<details class="third">
	   		<summary>PrintWriter</summary>
			   <div id="con"> <div id="space">
print,printf,println 등의 메소드가 오버로드되어 편리한 문자출력(가공) 스트림<br>
			   </div> </div>
	   	</details>
	   		   		<details class="third">
	   		<summary>ByteArrayInputStream</summary>
			   <div id="con"> <div id="space">
byte배열로부터 읽어올 수 있는 스트림<br>
			   </div> </div>
	   	</details>
	   		   		<details class="third">
	   		<summary>ByteOutputStream</summary>
			   <div id="con"> <div id="space">
byte배열에 데이터를 누적하여 저장할 수 있는 출력 스트림<br>
			   </div> </div>
	</details>
		   		   		<details class="third">
	   		<summary>StringReader</summary>
			   <div id="con"> <div id="space">
메모리에 있는 문자열로부터 문자를 읽어올 수 있는 입력스트림<br>
			   </div> </div>
	</details>
			   		   		<details class="third">
	   		<summary>DataInputStream</summary>
			   <div id="con"> <div id="space">
자바의 데이터형 그대로 읽어올 수 있는 필터스트림<br>
			   </div> </div>
	</details>
			   		   		<details class="third">
	   		<summary>DataOutputStream</summary>
			   <div id="con"> <div id="space">
자바의 데이터형 그대로 출력할 수 있는 바이트 스트림<br>
			   </div> </div>
	</details>
			   		   		<details class="third">
	   		<summary>ObjectInputStream</summary>
			   <div id="con"> <div id="space">
직렬화된 데이터를 다시 오브젝츠로 읽어올 수 있는 필터스트림<br>
			   </div> </div>
	</details>
			   		   		<details class="third">
	   		<summary>ObjectOutputStream</summary>
			   <div id="con"> <div id="space">
메모리에 있는 객체를 직렬화하여 저장할 수 있는 필터스트림<br>
			   </div> </div>
	</details>
			   		   		<details class="third">
	   		<summary>InputStreamReader</summary>
			   <div id="con"> <div id="space">
바이트 데이터를 일어와서 문자로 변환해주는 입력 변화 스트림<br>
			   </div> </div>
	</details>
			   		   		<details class="third">
	   		<summary>OutputStreamWriter</summary>
			   <div id="con"> <div id="space">
문자데이터를 바이트 데이터로 변환하여 출력해주는 변환 스트림<br>
			   </div> </div>
	</details>
	</details>
	   	</details>
	   	
	   	
	   	

<details>
   <summary>Network</summary>
	   <details class="second">
	   <summary>	Click Me! 2</summary>
	   <p>details, summary 같이 적용</p>
	</details>
</details>

</body>
</html>